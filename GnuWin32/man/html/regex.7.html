                                  <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>REGEX(7) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
regex - POSIX.2 regular expressions

<h2><a name='sect1' href='#toc1'>Description</a></h2>
Regular expressions (&lsquo;&lsquo;RE&rsquo;&rsquo;s), as defined in POSIX.2, come in two
forms: modern REs (roughly those of <i>egrep</i>; POSIX.2 calls these &lsquo;&lsquo;extended&rsquo;&rsquo;
REs) and obsolete REs (roughly those of <a href='ed.1.html'><b>ed</b>(1)</a>
; POSIX.2 &lsquo;&lsquo;basic&rsquo;&rsquo; REs). Obsolete
REs mostly exist for backward compatibility in some old programs; they
will be discussed at the end. POSIX.2 leaves some aspects of RE syntax and
semantics open; &lsquo;&rsquo; marks decisions on these aspects that may not be fully
portable to other POSIX.2 implementations. <p>
A (modern) RE is one or more non-empty
<i>branches</i>, separated by &lsquo;|&rsquo;. It matches anything that matches one of the branches.
<p>
A branch is one or more <i>pieces</i>, concatenated. It matches a match for the
first, followed by a match for the second, etc. <p>
A piece is an <i>atom</i> possibly
followed by a single &lsquo;*&rsquo;, &lsquo;+&rsquo;, &lsquo;?&rsquo;, or <i>bound</i>. An atom followed by &lsquo;*&rsquo; matches a
sequence of 0 or more matches of the atom. An atom followed by &lsquo;+&rsquo; matches
a sequence of 1 or more matches of the atom. An atom followed by &lsquo;?&rsquo; matches
a sequence of 0 or 1 matches of the atom. <p>
A <i>bound</i> is &lsquo;{&rsquo; followed by an unsigned
decimal integer, possibly followed by &lsquo;,&rsquo; possibly followed by another unsigned
decimal integer, always followed by &lsquo;}&rsquo;. The integers must lie between 0 and
RE_DUP_MAX (255) inclusive, and if there are two of them, the first may
not exceed the second. An atom followed by a bound containing one integer
<i>i</i> and no comma matches a sequence of exactly <i>i</i> matches of the atom. An atom
followed by a bound containing one integer <i>i</i> and a comma matches a sequence
of <i>i</i> or more matches of the atom. An atom followed by a bound containing
two integers <i>i</i> and <i>j</i> matches a sequence of <i>i</i> through <i>j</i> (inclusive) matches
of the atom. <p>
An atom is a regular expression enclosed in &lsquo;()&rsquo; (matching a
match for the regular expression), an empty set of &lsquo;()&rsquo; (matching the null
string), a <i>bracket expression</i> (see below), &lsquo;.&rsquo; (matching any single character),
&lsquo;^&rsquo; (matching the null string at the beginning of a line), &lsquo;$&rsquo; (matching the
null string at the end of a line), a &lsquo;\&rsquo; followed by one of the characters
&lsquo;^.[$()|*+?{\&rsquo; (matching that character taken as an ordinary character), a &lsquo;\&rsquo; followed
by any other character (matching that character taken as an ordinary character,
as if the &lsquo;\&rsquo; had not been present), or a single character with no other significance
(matching that character). A &lsquo;{&rsquo; followed by a character other than a digit
is an ordinary character, not the beginning of a bound. It is illegal to
end an RE with &lsquo;\&rsquo;. <p>
A <i>bracket expression</i> is a list of characters enclosed in
&lsquo;[]&rsquo;. It normally matches any single character from the list (but see below).
If the list begins with &lsquo;^&rsquo;, it matches any single character (but see below)
<i>not</i> from the rest of the list. If two characters in the list are separated
by &lsquo;-&rsquo;, this is shorthand for the full <i>range</i> of characters between those two
(inclusive) in the collating sequence, for example, &lsquo;[0-9]&rsquo; in ASCII matches
any decimal digit. It is illegal for two ranges to share an endpoint, for
example, &lsquo;a-c-e&rsquo;. Ranges are very collating-sequence-dependent, and portable programs
should avoid relying on them. <p>
To include a literal &lsquo;]&rsquo; in the list, make it
the first character (following a possible &lsquo;^&rsquo;). To include a literal &lsquo;-&rsquo;, make
it the first or last character, or the second endpoint of a range. To use
a literal &lsquo;-&rsquo; as the first endpoint of a range, enclose it in &lsquo;[.&rsquo; and &lsquo;.]&rsquo; to make
it a collating element (see below). With the exception of these and some
combinations using &lsquo;[&rsquo; (see next paragraphs), all other special characters,
including &lsquo;\&rsquo;, lose their special significance within a bracket expression.
<p>
Within a bracket expression, a collating element (a character, a multi-character
sequence that collates as if it were a single character, or a collating-sequence
name for either) enclosed in &lsquo;[.&rsquo; and &lsquo;.]&rsquo; stands for the sequence of characters
of that collating element. The sequence is a single element of the bracket
expression&rsquo;s list. A bracket expression containing a multi-character collating
element can thus match more than one character, for example, if the collating
sequence includes a &lsquo;ch&rsquo; collating element, then the RE &lsquo;[[.ch.]]*c&rsquo; matches
the first five characters of &lsquo;chchcc&rsquo;. <p>
Within a bracket expression, a collating
element enclosed in &lsquo;[=&rsquo; and &lsquo;=]&rsquo; is an equivalence class, standing for the
sequences of characters of all collating elements equivalent to that one,
including itself. (If there are no other equivalent collating elements,
the treatment is as if the enclosing delimiters were &lsquo;[.&rsquo; and &lsquo;.]&rsquo;.) For example,
if o and o&rsquo;o^&rsquo; are the members of an equivalence class, then &lsquo;[[=o=]]&rsquo;, &lsquo;[[=o&rsquo;o^&rsquo;=]]&rsquo;,
and &lsquo;[oo&rsquo;o^&rsquo;]&rsquo; are all synonymous. An equivalence class may not be an endpoint
of a range. <p>
Within a bracket expression, the name of a <i>character class</i> enclosed
in &lsquo;[:&rsquo; and &lsquo;:]&rsquo; stands for the list of all characters belonging to that class.
Standard character class names are: <p>
<blockquote><br>
<pre>alnum<tt> </tt>&nbsp;<tt> </tt>&nbsp;digit<tt> </tt>&nbsp;<tt> </tt>&nbsp;punct
alpha<tt> </tt>&nbsp;<tt> </tt>&nbsp;graph<tt> </tt>&nbsp;<tt> </tt>&nbsp;space
blank<tt> </tt>&nbsp;<tt> </tt>&nbsp;lower<tt> </tt>&nbsp;<tt> </tt>&nbsp;upper
cntrl<tt> </tt>&nbsp;<tt> </tt>&nbsp;print<tt> </tt>&nbsp;<tt> </tt>&nbsp;xdigit
</pre></blockquote>
<p>
These stand for the character classes defined in <a href='wctype.3.html'><b>wctype</b>(3)</a>
. A locale may
provide others. A character class may not be used as an endpoint of a range.
                   <p>
In the event that an RE could match more than one substring
of a given string, the RE matches the one starting earliest in the string.
If the RE could match more than one substring starting at that point, it
matches the longest. Subexpressions also match the longest possible substrings,
subject to the constraint that the whole match be as long as possible,
with subexpressions starting earlier in the RE taking priority over ones
starting later. Note that higher-level subexpressions thus take priority
over their lower-level component subexpressions. <p>
Match lengths are measured
in characters, not collating elements. A null string is considered longer
than no match at all. For example, &lsquo;bb*&rsquo; matches the three middle characters
of &lsquo;abbbc&rsquo;, &lsquo;(wee|week)(knights|nights)&rsquo; matches all ten characters of &lsquo;weeknights&rsquo;,
when &lsquo;(.*).*&rsquo; is matched against &lsquo;abc&rsquo; the parenthesized subexpression matches
all three characters, and when &lsquo;(a*)*&rsquo; is matched against &lsquo;bc&rsquo; both the whole
RE and the parenthesized subexpression match the null string. <p>
If case-independent
matching is specified, the effect is much as if all case distinctions had
vanished from the alphabet. When an alphabetic that exists in multiple cases
appears as an ordinary character outside a bracket expression, it is effectively
transformed into a bracket expression containing both cases, for example,
&lsquo;x&rsquo; becomes &lsquo;[xX]&rsquo;. When it appears inside a bracket expression, all case counterparts
of it are added to the bracket expression, so that, for example, &lsquo;[x]&rsquo; becomes
&lsquo;[xX]&rsquo; and &lsquo;[^x]&rsquo; becomes &lsquo;[^xX]&rsquo;. <p>
No particular limit is imposed on the length
of REs. Programs intended to be portable should not employ REs longer than
256 bytes, as an implementation can refuse to accept such REs and remain
POSIX-compliant. <p>
Obsolete (&lsquo;&lsquo;basic&rsquo;&rsquo;) regular expressions differ in several respects.
&lsquo;|&rsquo;, &lsquo;+&rsquo;, and &lsquo;?&rsquo; are ordinary characters and there is no equivalent for their
functionality. The delimiters for bounds are &lsquo;\{&rsquo; and &lsquo;\}&rsquo;, with &lsquo;{&rsquo; and &lsquo;}&rsquo; by themselves
ordinary characters. The parentheses for nested subexpressions are &lsquo;\(&rsquo; and
&lsquo;\)&rsquo;, with &lsquo;(&rsquo; and &lsquo;)&rsquo; by themselves ordinary characters. &lsquo;^&rsquo; is an ordinary character
except at the beginning of the RE or the beginning of a parenthesized subexpression,
&lsquo;$&rsquo; is an ordinary character except at the end of the RE or the end of a
parenthesized subexpression, and &lsquo;*&rsquo; is an ordinary character if it appears
at the beginning of the RE or the beginning of a parenthesized subexpression
(after a possible leading &lsquo;^&rsquo;). Finally, there is one new type of atom, a <i>back
reference</i>: &lsquo;\&rsquo; followed by a non-zero decimal digit <i>d</i> matches the same sequence
of characters matched by the <i>d</i>th parenthesized subexpression (numbering
subexpressions by the positions of their opening parentheses, left to right),
so that, for example, &lsquo;\([bc]\)\1&rsquo; matches &lsquo;bb&rsquo; or &lsquo;cc&rsquo; but not &lsquo;bc&rsquo;. 
<h2><a name='sect2' href='#toc2'>Bugs</a></h2>
Having two
kinds of REs is a botch. <p>
The current POSIX.2 spec says that &lsquo;)&rsquo; is an ordinary
character in the absence of an unmatched &lsquo;(&rsquo;; this was an unintentional result
of a wording error, and change is likely. Avoid relying on it. <p>
Back references
are a dreadful botch, posing major problems for efficient implementations.
They are also somewhat vaguely defined (does &lsquo;a\(\(b\)*\2\)*d&rsquo; match &lsquo;abbbd&rsquo;?). Avoid
using them. <p>
POSIX.2&rsquo;s specification of case-independent matching is vague. The
&lsquo;&lsquo;one case implies all cases&rsquo;&rsquo; definition given above is current consensus
among implementors as to the right interpretation. <p>
The syntax for word boundaries
is incredibly ugly.   
<h2><a name='sect3' href='#toc3'>See Also</a></h2>
<a href='regex.3.html'><b>regex</b>(3)</a>
 <p>
POSIX.2, section 2.8 (Regular Expression
Notation). <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Description</a></li>
<li><a name='toc2' href='#sect2'>Bugs</a></li>
<li><a name='toc3' href='#sect3'>See Also</a></li>
</ul>
</body>
</html>
